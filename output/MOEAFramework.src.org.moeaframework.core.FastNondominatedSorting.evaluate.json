{
    "original": {
        "method_name": "evaluate",
        "code": "@Override public void evaluate(Population population){  int N=population.size();  int[][] dominanceChecks=new int[N][N];  for (int i=0; i < N; i++) {    Solution si=population.get(i);    for (int j=i + 1; j < N; j++) {      if (i != j) {        Solution sj=population.get(j);        dominanceChecks[i][j]=comparator.compare(si,sj);        dominanceChecks[j][i]=-dominanceChecks[i][j];      }    }  }  int[] dominatedCounts=new int[N];  List<List<Integer>> dominatesList=new ArrayList<List<Integer>>();  List<Integer> currentFront=new ArrayList<Integer>();  for (int i=0; i < N; i++) {    List<Integer> dominates=new ArrayList<Integer>();    int dominatedCount=0;    for (int j=0; j < N; j++) {      if (i != j) {        if (dominanceChecks[i][j] < 0) {          dominates.add(j);        } else         if (dominanceChecks[j][i] < 0) {          dominatedCount+=1;        }      }    }    if (dominatedCount == 0) {      currentFront.add(i);    }    dominatesList.add(dominates);    dominatedCounts[i]=dominatedCount;  }  int rank=0;  while (!currentFront.isEmpty()) {    List<Integer> nextFront=new ArrayList<Integer>();    Population solutionsInFront=new Population();    for (int i=0; i < currentFront.size(); i++) {      Solution solution=population.get(currentFront.get(i));      solution.setAttribute(RANK_ATTRIBUTE,rank);      for (      Integer j : dominatesList.get(currentFront.get(i))) {        dominatedCounts[j]-=1;        if (dominatedCounts[j] == 0) {          nextFront.add(j);        }      }      solutionsInFront.add(solution);    }    updateCrowdingDistance(solutionsInFront);    rank+=1;    currentFront=nextFront;  }}",
        "extraction_name": null,
        "predictions": [
            "evaluateDominanceChecks",
            "evaluateDominanceChecks"
        ],
        "similarities": [
            0.7903481764993149,
            0.7903481764993149
        ],
        "file_name": "MOEAFramework.src.org.moeaframework.core.FastNondominatedSorting.evaluate.Original.java"
    },
    "extractions": [
        {
            "method_name": "evaluate",
            "code": "@Override public void evaluate(Population population){  int N=population.size();  int[][] dominanceChecks=new int[N][N];  for (int i=0; i < N; i++) {    Solution si=population.get(i);    for (int j=i + 1; j < N; j++) {      if (i != j) {        Solution sj=population.get(j);        dominanceChecks[i][j]=comparator.compare(si,sj);        dominanceChecks[j][i]=-dominanceChecks[i][j];      }    }  }  int[] dominatedCounts=new int[N];  List<List<Integer>> dominatesList=new ArrayList<List<Integer>>();  List<Integer> currentFront=new ArrayList<Integer>();  for (int i=0; i < N; i++) {    List<Integer> dominates=new ArrayList<Integer>();    int dominatedCount=0;    for (int j=0; j < N; j++) {      if (i != j) {        if (dominanceChecks[i][j] < 0) {          dominates.add(j);        } else         if (dominanceChecks[j][i] < 0) {          dominatedCount+=1;        }      }    }    if (dominatedCount == 0) {      currentFront.add(i);    }    dominatesList.add(dominates);    dominatedCounts[i]=dominatedCount;  }  int rank=0;  while (!currentFront.isEmpty()) {    List<Integer> nextFront=new ArrayList<Integer>();    Population solutionsInFront=new Population();    for (int i=0; i < currentFront.size(); i++) {      Solution solution=population.get(currentFront.get(i));      solution.setAttribute(RANK_ATTRIBUTE,rank);      evaluate_extraction_2(dominatedCounts,dominatesList,currentFront,nextFront,i);      solutionsInFront.add(solution);    }    updateCrowdingDistance(solutionsInFront);    rank+=1;    currentFront=nextFront;  }}",
            "extraction_name": "Extraction1",
            "prediction": "evaluateDominanceChecks",
            "similarity": null,
            "file_name": "MOEAFramework.src.org.moeaframework.core.FastNondominatedSorting.evaluate.Extraction1.java",
            "updated_code": "@Override public void evaluate(Population population){  int N=population.size();  int[][] dominanceChecks=new int[N][N];  for (int i=0; i < N; i++) {    Solution si=population.get(i);    for (int j=i + 1; j < N; j++) {      if (i != j) {        Solution sj=population.get(j);        dominanceChecks[i][j]=comparator.compare(si,sj);        dominanceChecks[j][i]=-dominanceChecks[i][j];      }    }  }  int[] dominatedCounts=new int[N];  List<List<Integer>> dominatesList=new ArrayList<List<Integer>>();  List<Integer> currentFront=new ArrayList<Integer>();  for (int i=0; i < N; i++) {    List<Integer> dominates=new ArrayList<Integer>();    int dominatedCount=0;    for (int j=0; j < N; j++) {      if (i != j) {        if (dominanceChecks[i][j] < 0) {          dominates.add(j);        } else         if (dominanceChecks[j][i] < 0) {          dominatedCount+=1;        }      }    }    if (dominatedCount == 0) {      currentFront.add(i);    }    dominatesList.add(dominates);    dominatedCounts[i]=dominatedCount;  }  int rank=0;  while (!currentFront.isEmpty()) {    List<Integer> nextFront=new ArrayList<Integer>();    Population solutionsInFront=new Population();    for (int i=0; i < currentFront.size(); i++) {      Solution solution=population.get(currentFront.get(i));      solution.setAttribute(RANK_ATTRIBUTE,rank);      evaluateDominanceChecks(dominatedCounts,dominatesList,currentFront,nextFront,i);      solutionsInFront.add(solution);    }    updateCrowdingDistance(solutionsInFront);    rank+=1;    currentFront=nextFront;  }}"
        },
        {
            "method_name": "evaluate",
            "code": "@Override public void evaluate(Population population){  int N=population.size();  int[][] dominanceChecks=new int[N][N];  for (int i=0; i < N; i++) {    Solution si=population.get(i);    for (int j=i + 1; j < N; j++) {      if (i != j) {        Solution sj=population.get(j);        dominanceChecks[i][j]=comparator.compare(si,sj);        dominanceChecks[j][i]=-dominanceChecks[i][j];      }    }  }  int[] dominatedCounts=new int[N];  List<List<Integer>> dominatesList=new ArrayList<List<Integer>>();  List<Integer> currentFront=new ArrayList<Integer>();  for (int i=0; i < N; i++) {    List<Integer> dominates=new ArrayList<Integer>();    int dominatedCount=0;    for (int j=0; j < N; j++) {      dominatedCount=evaluate_extraction_1(dominanceChecks,i,dominates,dominatedCount,j);    }    if (dominatedCount == 0) {      currentFront.add(i);    }    dominatesList.add(dominates);    dominatedCounts[i]=dominatedCount;  }  int rank=0;  while (!currentFront.isEmpty()) {    List<Integer> nextFront=new ArrayList<Integer>();    Population solutionsInFront=new Population();    for (int i=0; i < currentFront.size(); i++) {      Solution solution=population.get(currentFront.get(i));      solution.setAttribute(RANK_ATTRIBUTE,rank);      evaluate_extraction_2(dominatedCounts,dominatesList,currentFront,nextFront,i);      solutionsInFront.add(solution);    }    updateCrowdingDistance(solutionsInFront);    rank+=1;    currentFront=nextFront;  }}",
            "extraction_name": "Extraction2",
            "prediction": "evaluateDominanceChecks",
            "similarity": null,
            "file_name": "MOEAFramework.src.org.moeaframework.core.FastNondominatedSorting.evaluate.Extraction2.java",
            "updated_code": "@Override public void evaluate(Population population){  int N=population.size();  int[][] dominanceChecks=new int[N][N];  for (int i=0; i < N; i++) {    Solution si=population.get(i);    for (int j=i + 1; j < N; j++) {      if (i != j) {        Solution sj=population.get(j);        dominanceChecks[i][j]=comparator.compare(si,sj);        dominanceChecks[j][i]=-dominanceChecks[i][j];      }    }  }  int[] dominatedCounts=new int[N];  List<List<Integer>> dominatesList=new ArrayList<List<Integer>>();  List<Integer> currentFront=new ArrayList<Integer>();  for (int i=0; i < N; i++) {    List<Integer> dominates=new ArrayList<Integer>();    int dominatedCount=0;    for (int j=0; j < N; j++) {      dominatedCount=evaluateDominanceChecks(dominanceChecks,i,dominates,dominatedCount,j);    }    if (dominatedCount == 0) {      currentFront.add(i);    }    dominatesList.add(dominates);    dominatedCounts[i]=dominatedCount;  }  int rank=0;  while (!currentFront.isEmpty()) {    List<Integer> nextFront=new ArrayList<Integer>();    Population solutionsInFront=new Population();    for (int i=0; i < currentFront.size(); i++) {      Solution solution=population.get(currentFront.get(i));      solution.setAttribute(RANK_ATTRIBUTE,rank);      evaluateDominanceChecks(dominatedCounts,dominatesList,currentFront,nextFront,i);      solutionsInFront.add(solution);    }    updateCrowdingDistance(solutionsInFront);    rank+=1;    currentFront=nextFront;  }}"
        }
    ],
    "file_name": null
}