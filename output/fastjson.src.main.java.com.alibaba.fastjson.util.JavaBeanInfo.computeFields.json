{
    "original": {
        "method_name": "computeFields",
        "code": "private static void computeFields(Class<?> clazz,Type type,PropertyNamingStrategy propertyNamingStrategy,List<FieldInfo> fieldList,Field[] fields){  Map<TypeVariable,Type> genericInfo=buildGenericInfo(clazz);  for (  Field field : fields) {    int modifiers=field.getModifiers();    if ((modifiers & Modifier.STATIC) != 0) {      continue;    }    if ((modifiers & Modifier.FINAL) != 0) {      Class<?> fieldType=field.getType();      boolean supportReadOnly=Map.class.isAssignableFrom(fieldType) || Collection.class.isAssignableFrom(fieldType) || AtomicLong.class.equals(fieldType)|| AtomicInteger.class.equals(fieldType)|| AtomicBoolean.class.equals(fieldType);      if (!supportReadOnly) {        continue;      }    }    boolean contains=false;    for (    FieldInfo item : fieldList) {      if (item.name.equals(field.getName())) {        contains=true;        break;      }    }    if (contains) {      continue;    }    int ordinal=0, serialzeFeatures=0, parserFeatures=0;    String propertyName=field.getName();    JSONField fieldAnnotation=TypeUtils.getAnnotation(field,JSONField.class);    if (fieldAnnotation != null) {      if (!fieldAnnotation.deserialize()) {        continue;      }      ordinal=fieldAnnotation.ordinal();      serialzeFeatures=SerializerFeature.of(fieldAnnotation.serialzeFeatures());      parserFeatures=Feature.of(fieldAnnotation.parseFeatures());      if (fieldAnnotation.name().length() != 0) {        propertyName=fieldAnnotation.name();      }    }    if (propertyNamingStrategy != null) {      propertyName=propertyNamingStrategy.translate(propertyName);    }    add(fieldList,new FieldInfo(propertyName,null,field,clazz,type,ordinal,serialzeFeatures,parserFeatures,null,fieldAnnotation,null,genericInfo));  }}",
        "extraction_name": null,
        "predictions": [
            "computePropertyName",
            "computePropertyName",
            "computePropertyName",
            "computeFieldsInfo"
        ],
        "similarities": [
            0.5353363845400873,
            0.5353363845400873,
            0.5353363845400873,
            0.8212508610683041
        ],
        "file_name": "fastjson.src.main.java.com.alibaba.fastjson.util.JavaBeanInfo.computeFields.Original.java"
    },
    "extractions": [
        {
            "method_name": "computeFields",
            "code": "private static void computeFields(Class<?> clazz,Type type,PropertyNamingStrategy propertyNamingStrategy,List<FieldInfo> fieldList,Field[] fields){  Map<TypeVariable,Type> genericInfo=buildGenericInfo(clazz);  for (  Field field : fields) {    int modifiers=field.getModifiers();    if ((modifiers & Modifier.STATIC) != 0) {      continue;    }    if ((modifiers & Modifier.FINAL) != 0) {      Class<?> fieldType=field.getType();      boolean supportReadOnly=Map.class.isAssignableFrom(fieldType) || Collection.class.isAssignableFrom(fieldType) || AtomicLong.class.equals(fieldType)|| AtomicInteger.class.equals(fieldType)|| AtomicBoolean.class.equals(fieldType);      if (!supportReadOnly) {        continue;      }    }    boolean contains=false;    for (    FieldInfo item : fieldList) {      if (item.name.equals(field.getName())) {        contains=true;        break;      }    }    if (contains) {      continue;    }    int ordinal=0, serialzeFeatures=0, parserFeatures=0;    String propertyName=field.getName();    JSONField fieldAnnotation=TypeUtils.getAnnotation(field,JSONField.class);    if (fieldAnnotation != null) {      if (!fieldAnnotation.deserialize()) {        continue;      }      ordinal=fieldAnnotation.ordinal();      serialzeFeatures=SerializerFeature.of(fieldAnnotation.serialzeFeatures());      parserFeatures=Feature.of(fieldAnnotation.parseFeatures());      if (fieldAnnotation.name().length() != 0) {        propertyName=fieldAnnotation.name();      }    }    propertyName=computeFields_extraction_4(clazz,type,propertyNamingStrategy,fieldList,genericInfo,field,ordinal,serialzeFeatures,parserFeatures,propertyName,fieldAnnotation);  }}",
            "extraction_name": "Extraction1",
            "prediction": "computePropertyName",
            "similarity": null,
            "file_name": "fastjson.src.main.java.com.alibaba.fastjson.util.JavaBeanInfo.computeFields.Extraction1.java",
            "updated_code": "private static void computeFields(Class<?> clazz,Type type,PropertyNamingStrategy propertyNamingStrategy,List<FieldInfo> fieldList,Field[] fields){  Map<TypeVariable,Type> genericInfo=buildGenericInfo(clazz);  for (  Field field : fields) {    int modifiers=field.getModifiers();    if ((modifiers & Modifier.STATIC) != 0) {      continue;    }    if ((modifiers & Modifier.FINAL) != 0) {      Class<?> fieldType=field.getType();      boolean supportReadOnly=Map.class.isAssignableFrom(fieldType) || Collection.class.isAssignableFrom(fieldType) || AtomicLong.class.equals(fieldType)|| AtomicInteger.class.equals(fieldType)|| AtomicBoolean.class.equals(fieldType);      if (!supportReadOnly) {        continue;      }    }    boolean contains=false;    for (    FieldInfo item : fieldList) {      if (item.name.equals(field.getName())) {        contains=true;        break;      }    }    if (contains) {      continue;    }    int ordinal=0, serialzeFeatures=0, parserFeatures=0;    String propertyName=field.getName();    JSONField fieldAnnotation=TypeUtils.getAnnotation(field,JSONField.class);    if (fieldAnnotation != null) {      if (!fieldAnnotation.deserialize()) {        continue;      }      ordinal=fieldAnnotation.ordinal();      serialzeFeatures=SerializerFeature.of(fieldAnnotation.serialzeFeatures());      parserFeatures=Feature.of(fieldAnnotation.parseFeatures());      if (fieldAnnotation.name().length() != 0) {        propertyName=fieldAnnotation.name();      }    }    propertyName=computePropertyName(clazz,type,propertyNamingStrategy,fieldList,genericInfo,field,ordinal,serialzeFeatures,parserFeatures,propertyName,fieldAnnotation);  }}"
        },
        {
            "method_name": "computeFields",
            "code": "private static void computeFields(Class<?> clazz,Type type,PropertyNamingStrategy propertyNamingStrategy,List<FieldInfo> fieldList,Field[] fields){  Map<TypeVariable,Type> genericInfo=buildGenericInfo(clazz);  for (  Field field : fields) {    int modifiers=field.getModifiers();    if ((modifiers & Modifier.STATIC) != 0) {      continue;    }    if ((modifiers & Modifier.FINAL) != 0) {      Class<?> fieldType=field.getType();      boolean supportReadOnly=Map.class.isAssignableFrom(fieldType) || Collection.class.isAssignableFrom(fieldType) || AtomicLong.class.equals(fieldType)|| AtomicInteger.class.equals(fieldType)|| AtomicBoolean.class.equals(fieldType);      if (!supportReadOnly) {        continue;      }    }    boolean contains=false;    for (    FieldInfo item : fieldList) {      if (item.name.equals(field.getName())) {        contains=true;        break;      }    }    if (contains) {      continue;    }    int ordinal=0, serialzeFeatures=0, parserFeatures=0;    String propertyName=field.getName();    JSONField fieldAnnotation=TypeUtils.getAnnotation(field,JSONField.class);    if (fieldAnnotation != null) {      if (!fieldAnnotation.deserialize()) {        continue;      }      ordinal=fieldAnnotation.ordinal();      serialzeFeatures=SerializerFeature.of(fieldAnnotation.serialzeFeatures());      parserFeatures=Feature.of(fieldAnnotation.parseFeatures());      propertyName=computeFields_extraction_3(propertyName,fieldAnnotation);    }    propertyName=computeFields_extraction_4(clazz,type,propertyNamingStrategy,fieldList,genericInfo,field,ordinal,serialzeFeatures,parserFeatures,propertyName,fieldAnnotation);  }}",
            "extraction_name": "Extraction2",
            "prediction": "computeFieldName",
            "similarity": null,
            "file_name": "fastjson.src.main.java.com.alibaba.fastjson.util.JavaBeanInfo.computeFields.Extraction2.java",
            "updated_code": "private static void computeFields(Class<?> clazz,Type type,PropertyNamingStrategy propertyNamingStrategy,List<FieldInfo> fieldList,Field[] fields){  Map<TypeVariable,Type> genericInfo=buildGenericInfo(clazz);  for (  Field field : fields) {    int modifiers=field.getModifiers();    if ((modifiers & Modifier.STATIC) != 0) {      continue;    }    if ((modifiers & Modifier.FINAL) != 0) {      Class<?> fieldType=field.getType();      boolean supportReadOnly=Map.class.isAssignableFrom(fieldType) || Collection.class.isAssignableFrom(fieldType) || AtomicLong.class.equals(fieldType)|| AtomicInteger.class.equals(fieldType)|| AtomicBoolean.class.equals(fieldType);      if (!supportReadOnly) {        continue;      }    }    boolean contains=false;    for (    FieldInfo item : fieldList) {      if (item.name.equals(field.getName())) {        contains=true;        break;      }    }    if (contains) {      continue;    }    int ordinal=0, serialzeFeatures=0, parserFeatures=0;    String propertyName=field.getName();    JSONField fieldAnnotation=TypeUtils.getAnnotation(field,JSONField.class);    if (fieldAnnotation != null) {      if (!fieldAnnotation.deserialize()) {        continue;      }      ordinal=fieldAnnotation.ordinal();      serialzeFeatures=SerializerFeature.of(fieldAnnotation.serialzeFeatures());      parserFeatures=Feature.of(fieldAnnotation.parseFeatures());      propertyName=computeFieldName(propertyName,fieldAnnotation);    }    propertyName=computePropertyName(clazz,type,propertyNamingStrategy,fieldList,genericInfo,field,ordinal,serialzeFeatures,parserFeatures,propertyName,fieldAnnotation);  }}"
        },
        {
            "method_name": "computeFields",
            "code": "private static void computeFields(Class<?> clazz,Type type,PropertyNamingStrategy propertyNamingStrategy,List<FieldInfo> fieldList,Field[] fields){  Map<TypeVariable,Type> genericInfo=buildGenericInfo(clazz);  for (  Field field : fields) {    int modifiers=field.getModifiers();    if ((modifiers & Modifier.STATIC) != 0) {      continue;    }    if ((modifiers & Modifier.FINAL) != 0) {      Class<?> fieldType=field.getType();      boolean supportReadOnly=Map.class.isAssignableFrom(fieldType) || Collection.class.isAssignableFrom(fieldType) || AtomicLong.class.equals(fieldType)|| AtomicInteger.class.equals(fieldType)|| AtomicBoolean.class.equals(fieldType);      if (!supportReadOnly) {        continue;      }    }    boolean contains=computeFields_extraction_2(fieldList,field);    if (contains) {      continue;    }    int ordinal=0, serialzeFeatures=0, parserFeatures=0;    String propertyName=field.getName();    JSONField fieldAnnotation=TypeUtils.getAnnotation(field,JSONField.class);    if (fieldAnnotation != null) {      if (!fieldAnnotation.deserialize()) {        continue;      }      ordinal=fieldAnnotation.ordinal();      serialzeFeatures=SerializerFeature.of(fieldAnnotation.serialzeFeatures());      parserFeatures=Feature.of(fieldAnnotation.parseFeatures());      propertyName=computeFields_extraction_3(propertyName,fieldAnnotation);    }    propertyName=computeFields_extraction_4(clazz,type,propertyNamingStrategy,fieldList,genericInfo,field,ordinal,serialzeFeatures,parserFeatures,propertyName,fieldAnnotation);  }}",
            "extraction_name": "Extraction3",
            "prediction": "computeFieldContains",
            "similarity": null,
            "file_name": "fastjson.src.main.java.com.alibaba.fastjson.util.JavaBeanInfo.computeFields.Extraction3.java",
            "updated_code": "private static void computeFields(Class<?> clazz,Type type,PropertyNamingStrategy propertyNamingStrategy,List<FieldInfo> fieldList,Field[] fields){  Map<TypeVariable,Type> genericInfo=buildGenericInfo(clazz);  for (  Field field : fields) {    int modifiers=field.getModifiers();    if ((modifiers & Modifier.STATIC) != 0) {      continue;    }    if ((modifiers & Modifier.FINAL) != 0) {      Class<?> fieldType=field.getType();      boolean supportReadOnly=Map.class.isAssignableFrom(fieldType) || Collection.class.isAssignableFrom(fieldType) || AtomicLong.class.equals(fieldType)|| AtomicInteger.class.equals(fieldType)|| AtomicBoolean.class.equals(fieldType);      if (!supportReadOnly) {        continue;      }    }    boolean contains=computeFieldContains(fieldList,field);    if (contains) {      continue;    }    int ordinal=0, serialzeFeatures=0, parserFeatures=0;    String propertyName=field.getName();    JSONField fieldAnnotation=TypeUtils.getAnnotation(field,JSONField.class);    if (fieldAnnotation != null) {      if (!fieldAnnotation.deserialize()) {        continue;      }      ordinal=fieldAnnotation.ordinal();      serialzeFeatures=SerializerFeature.of(fieldAnnotation.serialzeFeatures());      parserFeatures=Feature.of(fieldAnnotation.parseFeatures());      propertyName=computeFieldName(propertyName,fieldAnnotation);    }    propertyName=computePropertyName(clazz,type,propertyNamingStrategy,fieldList,genericInfo,field,ordinal,serialzeFeatures,parserFeatures,propertyName,fieldAnnotation);  }}"
        },
        {
            "method_name": "computeFields",
            "code": "private static void computeFields(Class<?> clazz,Type type,PropertyNamingStrategy propertyNamingStrategy,List<FieldInfo> fieldList,Field[] fields){  Map<TypeVariable,Type> genericInfo=buildGenericInfo(clazz);  for (  Field field : fields) {    int modifiers=field.getModifiers();    if ((modifiers & Modifier.STATIC) != 0) {      continue;    }    if ((modifiers & Modifier.FINAL) != 0) {      boolean supportReadOnly=computeFields_extraction_1(field);      if (!supportReadOnly) {        continue;      }    }    boolean contains=computeFields_extraction_2(fieldList,field);    if (contains) {      continue;    }    int ordinal=0, serialzeFeatures=0, parserFeatures=0;    String propertyName=field.getName();    JSONField fieldAnnotation=TypeUtils.getAnnotation(field,JSONField.class);    if (fieldAnnotation != null) {      if (!fieldAnnotation.deserialize()) {        continue;      }      ordinal=fieldAnnotation.ordinal();      serialzeFeatures=SerializerFeature.of(fieldAnnotation.serialzeFeatures());      parserFeatures=Feature.of(fieldAnnotation.parseFeatures());      propertyName=computeFields_extraction_3(propertyName,fieldAnnotation);    }    propertyName=computeFields_extraction_4(clazz,type,propertyNamingStrategy,fieldList,genericInfo,field,ordinal,serialzeFeatures,parserFeatures,propertyName,fieldAnnotation);  }}",
            "extraction_name": "Extraction4",
            "prediction": "computeFieldsReadOnly",
            "similarity": null,
            "file_name": "fastjson.src.main.java.com.alibaba.fastjson.util.JavaBeanInfo.computeFields.Extraction4.java",
            "updated_code": "private static void computeFields(Class<?> clazz,Type type,PropertyNamingStrategy propertyNamingStrategy,List<FieldInfo> fieldList,Field[] fields){  Map<TypeVariable,Type> genericInfo=buildGenericInfo(clazz);  for (  Field field : fields) {    int modifiers=field.getModifiers();    if ((modifiers & Modifier.STATIC) != 0) {      continue;    }    if ((modifiers & Modifier.FINAL) != 0) {      boolean supportReadOnly=computeFieldsReadOnly(field);      if (!supportReadOnly) {        continue;      }    }    boolean contains=computeFieldContains(fieldList,field);    if (contains) {      continue;    }    int ordinal=0, serialzeFeatures=0, parserFeatures=0;    String propertyName=field.getName();    JSONField fieldAnnotation=TypeUtils.getAnnotation(field,JSONField.class);    if (fieldAnnotation != null) {      if (!fieldAnnotation.deserialize()) {        continue;      }      ordinal=fieldAnnotation.ordinal();      serialzeFeatures=SerializerFeature.of(fieldAnnotation.serialzeFeatures());      parserFeatures=Feature.of(fieldAnnotation.parseFeatures());      propertyName=computeFieldName(propertyName,fieldAnnotation);    }    propertyName=computePropertyName(clazz,type,propertyNamingStrategy,fieldList,genericInfo,field,ordinal,serialzeFeatures,parserFeatures,propertyName,fieldAnnotation);  }}"
        }
    ],
    "file_name": null
}