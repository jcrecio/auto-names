{
    "original": {
        "method_name": "matingSelection",
        "code": "/**  * Select two parents for reproduction */public List<S> matingSelection(int cid,int type){  int rnd1, rnd2;  List<S> parents=new ArrayList<>(2);  int nLength=neighborhood[cid].length;  ArrayList<Integer> activeList=new ArrayList<>();  if (type == 1) {    for (int i=0; i < nLength; i++) {      int idx=neighborhood[cid][i];      for (int j=0; j < populationSize; j++) {        if (subregionIdx[idx][j] == 1) {          activeList.add(idx);          break;        }      }    }    if (activeList.size() < 2) {      activeList.clear();      for (int i=0; i < populationSize; i++) {        for (int j=0; j < populationSize; j++) {          if (subregionIdx[i][j] == 1) {            activeList.add(i);            break;          }        }      }    }    int activeSize=activeList.size();    rnd1=randomGenerator.nextInt(0,activeSize - 1);    do {      rnd2=randomGenerator.nextInt(0,activeSize - 1);    } while (rnd1 == rnd2);    ArrayList<Integer> list1=new ArrayList<>();    ArrayList<Integer> list2=new ArrayList<>();    int id1=activeList.get(rnd1);    int id2=activeList.get(rnd2);    for (int i=0; i < populationSize; i++) {      if (subregionIdx[id1][i] == 1) {        list1.add(i);      }      if (subregionIdx[id2][i] == 1) {        list2.add(i);      }    }    int p1=randomGenerator.nextInt(0,list1.size() - 1);    int p2=randomGenerator.nextInt(0,list2.size() - 1);    parents.add(population.get(list1.get(p1)));    parents.add(population.get(list2.get(p2)));  } else {    for (int i=0; i < populationSize; i++) {      for (int j=0; j < populationSize; j++) {        if (subregionIdx[i][j] == 1) {          activeList.add(i);          break;        }      }    }    int activeSize=activeList.size();    rnd1=randomGenerator.nextInt(0,activeSize - 1);    do {      rnd2=randomGenerator.nextInt(0,activeSize - 1);    } while (rnd1 == rnd2);    ArrayList<Integer> list1=new ArrayList<>();    ArrayList<Integer> list2=new ArrayList<>();    int id1=activeList.get(rnd1);    int id2=activeList.get(rnd2);    for (int i=0; i < populationSize; i++) {      if (subregionIdx[id1][i] == 1) {        list1.add(i);      }      if (subregionIdx[id2][i] == 1) {        list2.add(i);      }    }    int p1=randomGenerator.nextInt(0,list1.size() - 1);    int p2=randomGenerator.nextInt(0,list2.size() - 1);    parents.add(population.get(list1.get(p1)));    parents.add(population.get(list2.get(p2)));  }  return parents;}",
        "extraction_name": null,
        "predictions": [
            "selectParentsForReproduction",
            "selectParents",
            "matingSelection_selectParents"
        ],
        "similarities": [
            0.7295380054719347,
            0.5037746232603576,
            0.9116972511126428
        ],
        "file_name": "jmetal-algorithm.src.main.java.org.uma.jmetal.algorithm.multiobjective.moead.MOEADD.matingSelection.Original.java"
    },
    "extractions": [
        {
            "method_name": "matingSelection",
            "code": "/**  * Select two parents for reproduction */public List<S> matingSelection(int cid,int type){  int rnd1, rnd2;  List<S> parents=new ArrayList<>(2);  int nLength=neighborhood[cid].length;  ArrayList<Integer> activeList=new ArrayList<>();  if (type == 1) {    for (int i=0; i < nLength; i++) {      int idx=neighborhood[cid][i];      for (int j=0; j < populationSize; j++) {        if (subregionIdx[idx][j] == 1) {          activeList.add(idx);          break;        }      }    }    if (activeList.size() < 2) {      activeList.clear();      for (int i=0; i < populationSize; i++) {        for (int j=0; j < populationSize; j++) {          if (subregionIdx[i][j] == 1) {            activeList.add(i);            break;          }        }      }    }    int activeSize=activeList.size();    rnd1=randomGenerator.nextInt(0,activeSize - 1);    do {      rnd2=randomGenerator.nextInt(0,activeSize - 1);    } while (rnd1 == rnd2);    ArrayList<Integer> list1=new ArrayList<>();    ArrayList<Integer> list2=new ArrayList<>();    int id1=activeList.get(rnd1);    int id2=activeList.get(rnd2);    for (int i=0; i < populationSize; i++) {      if (subregionIdx[id1][i] == 1) {        list1.add(i);      }      if (subregionIdx[id2][i] == 1) {        list2.add(i);      }    }    int p1=randomGenerator.nextInt(0,list1.size() - 1);    int p2=randomGenerator.nextInt(0,list2.size() - 1);    parents.add(population.get(list1.get(p1)));    parents.add(population.get(list2.get(p2)));  } else {    matingSelection_extraction_3(parents,activeList);  }  return parents;}",
            "extraction_name": "Extraction1",
            "prediction": "matingSelection_extraction_3_method",
            "similarity": null,
            "file_name": "jmetal-algorithm.src.main.java.org.uma.jmetal.algorithm.multiobjective.moead.MOEADD.matingSelection.Extraction1.java",
            "updated_code": "/**  * Select two parents for reproduction */public List<S> matingSelection(int cid,int type){  int rnd1, rnd2;  List<S> parents=new ArrayList<>(2);  int nLength=neighborhood[cid].length;  ArrayList<Integer> activeList=new ArrayList<>();  if (type == 1) {    for (int i=0; i < nLength; i++) {      int idx=neighborhood[cid][i];      for (int j=0; j < populationSize; j++) {        if (subregionIdx[idx][j] == 1) {          activeList.add(idx);          break;        }      }    }    if (activeList.size() < 2) {      activeList.clear();      for (int i=0; i < populationSize; i++) {        for (int j=0; j < populationSize; j++) {          if (subregionIdx[i][j] == 1) {            activeList.add(i);            break;          }        }      }    }    int activeSize=activeList.size();    rnd1=randomGenerator.nextInt(0,activeSize - 1);    do {      rnd2=randomGenerator.nextInt(0,activeSize - 1);    } while (rnd1 == rnd2);    ArrayList<Integer> list1=new ArrayList<>();    ArrayList<Integer> list2=new ArrayList<>();    int id1=activeList.get(rnd1);    int id2=activeList.get(rnd2);    for (int i=0; i < populationSize; i++) {      if (subregionIdx[id1][i] == 1) {        list1.add(i);      }      if (subregionIdx[id2][i] == 1) {        list2.add(i);      }    }    int p1=randomGenerator.nextInt(0,list1.size() - 1);    int p2=randomGenerator.nextInt(0,list2.size() - 1);    parents.add(population.get(list1.get(p1)));    parents.add(population.get(list2.get(p2)));  } else {    matingSelection_extraction_3_method(parents,activeList);  }  return parents;}"
        },
        {
            "method_name": "matingSelection",
            "code": "/**  * Select two parents for reproduction */public List<S> matingSelection(int cid,int type){  int rnd1, rnd2;  List<S> parents=new ArrayList<>(2);  int nLength=neighborhood[cid].length;  ArrayList<Integer> activeList=new ArrayList<>();  if (type == 1) {    for (int i=0; i < nLength; i++) {      int idx=neighborhood[cid][i];      for (int j=0; j < populationSize; j++) {        if (subregionIdx[idx][j] == 1) {          activeList.add(idx);          break;        }      }    }    if (activeList.size() < 2) {      activeList.clear();      for (int i=0; i < populationSize; i++) {        for (int j=0; j < populationSize; j++) {          if (subregionIdx[i][j] == 1) {            activeList.add(i);            break;          }        }      }    }    int activeSize=activeList.size();    matingSelection_extraction_2(parents,activeList,activeSize);  } else {    matingSelection_extraction_3(parents,activeList);  }  return parents;}",
            "extraction_name": "Extraction2",
            "prediction": "matingSelection_selectParents",
            "similarity": null,
            "file_name": "jmetal-algorithm.src.main.java.org.uma.jmetal.algorithm.multiobjective.moead.MOEADD.matingSelection.Extraction2.java",
            "updated_code": "/**  * Select two parents for reproduction */public List<S> matingSelection(int cid,int type){  int rnd1, rnd2;  List<S> parents=new ArrayList<>(2);  int nLength=neighborhood[cid].length;  ArrayList<Integer> activeList=new ArrayList<>();  if (type == 1) {    for (int i=0; i < nLength; i++) {      int idx=neighborhood[cid][i];      for (int j=0; j < populationSize; j++) {        if (subregionIdx[idx][j] == 1) {          activeList.add(idx);          break;        }      }    }    if (activeList.size() < 2) {      activeList.clear();      for (int i=0; i < populationSize; i++) {        for (int j=0; j < populationSize; j++) {          if (subregionIdx[i][j] == 1) {            activeList.add(i);            break;          }        }      }    }    int activeSize=activeList.size();    matingSelection_selectParents(parents,activeList,activeSize);  } else {    matingSelection_extraction_3_method(parents,activeList);  }  return parents;}"
        },
        {
            "method_name": "matingSelection",
            "code": "/**  * Select two parents for reproduction */public List<S> matingSelection(int cid,int type){  int rnd1, rnd2;  List<S> parents=new ArrayList<>(2);  int nLength=neighborhood[cid].length;  ArrayList<Integer> activeList=new ArrayList<>();  if (type == 1) {    for (int i=0; i < nLength; i++) {      int idx=neighborhood[cid][i];      for (int j=0; j < populationSize; j++) {        if (subregionIdx[idx][j] == 1) {          activeList.add(idx);          break;        }      }    }    if (activeList.size() < 2) {      activeList.clear();      matingSelection_extraction_1(activeList);    }    int activeSize=activeList.size();    matingSelection_extraction_2(parents,activeList,activeSize);  } else {    matingSelection_extraction_3(parents,activeList);  }  return parents;}",
            "extraction_name": "Extraction3",
            "prediction": "matingSelection_extractActiveList",
            "similarity": null,
            "file_name": "jmetal-algorithm.src.main.java.org.uma.jmetal.algorithm.multiobjective.moead.MOEADD.matingSelection.Extraction3.java",
            "updated_code": "/**  * Select two parents for reproduction */public List<S> matingSelection(int cid,int type){  int rnd1, rnd2;  List<S> parents=new ArrayList<>(2);  int nLength=neighborhood[cid].length;  ArrayList<Integer> activeList=new ArrayList<>();  if (type == 1) {    for (int i=0; i < nLength; i++) {      int idx=neighborhood[cid][i];      for (int j=0; j < populationSize; j++) {        if (subregionIdx[idx][j] == 1) {          activeList.add(idx);          break;        }      }    }    if (activeList.size() < 2) {      activeList.clear();      matingSelection_extractActiveList(activeList);    }    int activeSize=activeList.size();    matingSelection_selectParents(parents,activeList,activeSize);  } else {    matingSelection_extraction_3_method(parents,activeList);  }  return parents;}"
        }
    ],
    "file_name": null
}