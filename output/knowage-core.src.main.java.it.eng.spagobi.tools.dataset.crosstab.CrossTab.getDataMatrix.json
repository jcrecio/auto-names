{
    "original": {
        "method_name": "getDataMatrix",
        "code": "/**  * Get the matrix that represent the data * @param columnsSpecification: A list with all the possible coordinates of the columns * @param rowsSpecification:    A list with all the possible coordinates of the rows * @param columnCordinates:     A list with the column coordinates of all the data * @param rowCordinates:        A list with the column rows of all the data * @param data:                 A list with the data * @param measuresOnColumns:    true if the measures live in the columns, false if the measures live in the rows * @param measuresLength:       the number of the measures * @return the matrix that represent the data */private String[][] getDataMatrix(List<String> columnsSpecification,List<String> rowsSpecification,List<String> columnCordinates,List<String> rowCordinates,List<String> data,boolean measuresOnColumns,int measuresLength,int columnsN){  String[][] dataMatrix;  int x, y;  int rowsN;  if (measuresOnColumns) {    rowsN=(rowsSpecification.size() > 0 ? rowsSpecification.size() : 1);  } else {    rowsN=(rowsSpecification.size() > 0 ? rowsSpecification.size() : 1) * measuresLength;  }  dataMatrix=new String[rowsN][columnsN];  for (int i=0; i < rowsN; i++) {    for (int j=0; j < columnsN; j++) {      dataMatrix[i][j]=DATA_MATRIX_NA;    }  }  if (measuresOnColumns) {    for (int i=0; i < data.size(); i=i + measuresLength) {      for (int j=0; j < measuresLength; j++) {        if (rowsSpecification.size() > 0) {          x=rowsSpecification.indexOf(rowCordinates.get(i + j));          if (x < 0) {            continue;          }        } else {          x=0;        }        if (columnsSpecification.size() > 0) {          y=columnsSpecification.indexOf(columnCordinates.get(i + j));          if (y < 0) {            continue;          }        } else {          y=0;        }        if ((y * measuresLength + j) < columnsN && (y * measuresLength + j) >= 0) {          dataMatrix[x][y * measuresLength + j]=data.get(i + j);        }      }    }  } else {    for (int i=0; i < data.size(); i=i + measuresLength) {      for (int j=0; j < measuresLength; j++) {        if (rowsSpecification.size() > 0) {          x=rowsSpecification.indexOf(rowCordinates.get(i + j));          if (x < 0) {            continue;          }        } else {          x=0;        }        if (columnsSpecification.size() > 0) {          y=columnsSpecification.indexOf(columnCordinates.get(i + j));          if (y < 0) {            continue;          }        } else {          y=0;        }        if (y < columnsN && y >= 0) {          dataMatrix[x * measuresLength + j][y]=data.get(i + j);        }      }    }  }  return dataMatrix;}",
        "extraction_name": null,
        "predictions": [
            "getDataMatrixCoordinates",
            "getDataMatrixCoordinates",
            "getDataMatrixCoordinates"
        ],
        "similarities": [
            0.9779123439996343,
            0.9779123439996343,
            0.9779123439996343
        ],
        "file_name": "knowage-core.src.main.java.it.eng.spagobi.tools.dataset.crosstab.CrossTab.getDataMatrix.Original.java"
    },
    "extractions": [
        {
            "method_name": "getDataMatrix",
            "code": "/**  * Get the matrix that represent the data * @param columnsSpecification: A list with all the possible coordinates of the columns * @param rowsSpecification:    A list with all the possible coordinates of the rows * @param columnCordinates:     A list with the column coordinates of all the data * @param rowCordinates:        A list with the column rows of all the data * @param data:                 A list with the data * @param measuresOnColumns:    true if the measures live in the columns, false if the measures live in the rows * @param measuresLength:       the number of the measures * @return the matrix that represent the data */private String[][] getDataMatrix(List<String> columnsSpecification,List<String> rowsSpecification,List<String> columnCordinates,List<String> rowCordinates,List<String> data,boolean measuresOnColumns,int measuresLength,int columnsN){  String[][] dataMatrix;  int x, y;  int rowsN;  if (measuresOnColumns) {    rowsN=(rowsSpecification.size() > 0 ? rowsSpecification.size() : 1);  } else {    rowsN=(rowsSpecification.size() > 0 ? rowsSpecification.size() : 1) * measuresLength;  }  dataMatrix=new String[rowsN][columnsN];  for (int i=0; i < rowsN; i++) {    for (int j=0; j < columnsN; j++) {      dataMatrix[i][j]=DATA_MATRIX_NA;    }  }  if (measuresOnColumns) {    for (int i=0; i < data.size(); i=i + measuresLength) {      for (int j=0; j < measuresLength; j++) {        if (rowsSpecification.size() > 0) {          x=rowsSpecification.indexOf(rowCordinates.get(i + j));          if (x < 0) {            continue;          }        } else {          x=0;        }        if (columnsSpecification.size() > 0) {          y=columnsSpecification.indexOf(columnCordinates.get(i + j));          if (y < 0) {            continue;          }        } else {          y=0;        }        if ((y * measuresLength + j) < columnsN && (y * measuresLength + j) >= 0) {          dataMatrix[x][y * measuresLength + j]=data.get(i + j);        }      }    }  } else {    for (int i=0; i < data.size(); i=i + measuresLength) {      for (int j=0; j < measuresLength; j++) {        y=getDataMatrix_extraction_3(columnsSpecification,rowsSpecification,columnCordinates,rowCordinates,data,measuresLength,columnsN,dataMatrix,y,i,j);      }    }  }  return dataMatrix;}",
            "extraction_name": "Extraction1",
            "prediction": "getDataMatrixCoordinates",
            "similarity": null,
            "file_name": "knowage-core.src.main.java.it.eng.spagobi.tools.dataset.crosstab.CrossTab.getDataMatrix.Extraction1.java",
            "updated_code": "/**  * Get the matrix that represent the data * @param columnsSpecification: A list with all the possible coordinates of the columns * @param rowsSpecification:    A list with all the possible coordinates of the rows * @param columnCordinates:     A list with the column coordinates of all the data * @param rowCordinates:        A list with the column rows of all the data * @param data:                 A list with the data * @param measuresOnColumns:    true if the measures live in the columns, false if the measures live in the rows * @param measuresLength:       the number of the measures * @return the matrix that represent the data */private String[][] getDataMatrix(List<String> columnsSpecification,List<String> rowsSpecification,List<String> columnCordinates,List<String> rowCordinates,List<String> data,boolean measuresOnColumns,int measuresLength,int columnsN){  String[][] dataMatrix;  int x, y;  int rowsN;  if (measuresOnColumns) {    rowsN=(rowsSpecification.size() > 0 ? rowsSpecification.size() : 1);  } else {    rowsN=(rowsSpecification.size() > 0 ? rowsSpecification.size() : 1) * measuresLength;  }  dataMatrix=new String[rowsN][columnsN];  for (int i=0; i < rowsN; i++) {    for (int j=0; j < columnsN; j++) {      dataMatrix[i][j]=DATA_MATRIX_NA;    }  }  if (measuresOnColumns) {    for (int i=0; i < data.size(); i=i + measuresLength) {      for (int j=0; j < measuresLength; j++) {        if (rowsSpecification.size() > 0) {          x=rowsSpecification.indexOf(rowCordinates.get(i + j));          if (x < 0) {            continue;          }        } else {          x=0;        }        if (columnsSpecification.size() > 0) {          y=columnsSpecification.indexOf(columnCordinates.get(i + j));          if (y < 0) {            continue;          }        } else {          y=0;        }        if ((y * measuresLength + j) < columnsN && (y * measuresLength + j) >= 0) {          dataMatrix[x][y * measuresLength + j]=data.get(i + j);        }      }    }  } else {    for (int i=0; i < data.size(); i=i + measuresLength) {      for (int j=0; j < measuresLength; j++) {        y=getDataMatrixCoordinates(columnsSpecification,rowsSpecification,columnCordinates,rowCordinates,data,measuresLength,columnsN,dataMatrix,y,i,j);      }    }  }  return dataMatrix;}"
        },
        {
            "method_name": "getDataMatrix",
            "code": "/**  * Get the matrix that represent the data * @param columnsSpecification: A list with all the possible coordinates of the columns * @param rowsSpecification:    A list with all the possible coordinates of the rows * @param columnCordinates:     A list with the column coordinates of all the data * @param rowCordinates:        A list with the column rows of all the data * @param data:                 A list with the data * @param measuresOnColumns:    true if the measures live in the columns, false if the measures live in the rows * @param measuresLength:       the number of the measures * @return the matrix that represent the data */private String[][] getDataMatrix(List<String> columnsSpecification,List<String> rowsSpecification,List<String> columnCordinates,List<String> rowCordinates,List<String> data,boolean measuresOnColumns,int measuresLength,int columnsN){  String[][] dataMatrix;  int x, y;  int rowsN;  if (measuresOnColumns) {    rowsN=(rowsSpecification.size() > 0 ? rowsSpecification.size() : 1);  } else {    rowsN=(rowsSpecification.size() > 0 ? rowsSpecification.size() : 1) * measuresLength;  }  dataMatrix=new String[rowsN][columnsN];  for (int i=0; i < rowsN; i++) {    for (int j=0; j < columnsN; j++) {      dataMatrix[i][j]=DATA_MATRIX_NA;    }  }  if (measuresOnColumns) {    for (int i=0; i < data.size(); i=i + measuresLength) {      for (int j=0; j < measuresLength; j++) {        y=getDataMatrix_extraction_2(columnsSpecification,rowsSpecification,columnCordinates,rowCordinates,data,measuresLength,columnsN,dataMatrix,y,i,j);      }    }  } else {    for (int i=0; i < data.size(); i=i + measuresLength) {      for (int j=0; j < measuresLength; j++) {        y=getDataMatrix_extraction_3(columnsSpecification,rowsSpecification,columnCordinates,rowCordinates,data,measuresLength,columnsN,dataMatrix,y,i,j);      }    }  }  return dataMatrix;}",
            "extraction_name": "Extraction2",
            "prediction": "getDataMatrixCoordinates",
            "similarity": null,
            "file_name": "knowage-core.src.main.java.it.eng.spagobi.tools.dataset.crosstab.CrossTab.getDataMatrix.Extraction2.java",
            "updated_code": "/**  * Get the matrix that represent the data * @param columnsSpecification: A list with all the possible coordinates of the columns * @param rowsSpecification:    A list with all the possible coordinates of the rows * @param columnCordinates:     A list with the column coordinates of all the data * @param rowCordinates:        A list with the column rows of all the data * @param data:                 A list with the data * @param measuresOnColumns:    true if the measures live in the columns, false if the measures live in the rows * @param measuresLength:       the number of the measures * @return the matrix that represent the data */private String[][] getDataMatrix(List<String> columnsSpecification,List<String> rowsSpecification,List<String> columnCordinates,List<String> rowCordinates,List<String> data,boolean measuresOnColumns,int measuresLength,int columnsN){  String[][] dataMatrix;  int x, y;  int rowsN;  if (measuresOnColumns) {    rowsN=(rowsSpecification.size() > 0 ? rowsSpecification.size() : 1);  } else {    rowsN=(rowsSpecification.size() > 0 ? rowsSpecification.size() : 1) * measuresLength;  }  dataMatrix=new String[rowsN][columnsN];  for (int i=0; i < rowsN; i++) {    for (int j=0; j < columnsN; j++) {      dataMatrix[i][j]=DATA_MATRIX_NA;    }  }  if (measuresOnColumns) {    for (int i=0; i < data.size(); i=i + measuresLength) {      for (int j=0; j < measuresLength; j++) {        y=getDataMatrixCoordinates(columnsSpecification,rowsSpecification,columnCordinates,rowCordinates,data,measuresLength,columnsN,dataMatrix,y,i,j);      }    }  } else {    for (int i=0; i < data.size(); i=i + measuresLength) {      for (int j=0; j < measuresLength; j++) {        y=getDataMatrixCoordinates(columnsSpecification,rowsSpecification,columnCordinates,rowCordinates,data,measuresLength,columnsN,dataMatrix,y,i,j);      }    }  }  return dataMatrix;}"
        },
        {
            "method_name": "getDataMatrix",
            "code": "/**  * Get the matrix that represent the data * @param columnsSpecification: A list with all the possible coordinates of the columns * @param rowsSpecification:    A list with all the possible coordinates of the rows * @param columnCordinates:     A list with the column coordinates of all the data * @param rowCordinates:        A list with the column rows of all the data * @param data:                 A list with the data * @param measuresOnColumns:    true if the measures live in the columns, false if the measures live in the rows * @param measuresLength:       the number of the measures * @return the matrix that represent the data */private String[][] getDataMatrix(List<String> columnsSpecification,List<String> rowsSpecification,List<String> columnCordinates,List<String> rowCordinates,List<String> data,boolean measuresOnColumns,int measuresLength,int columnsN){  String[][] dataMatrix;  int x, y;  dataMatrix=getDataMatrix_extraction_1(rowsSpecification,measuresOnColumns,measuresLength,columnsN);  if (measuresOnColumns) {    for (int i=0; i < data.size(); i=i + measuresLength) {      for (int j=0; j < measuresLength; j++) {        y=getDataMatrix_extraction_2(columnsSpecification,rowsSpecification,columnCordinates,rowCordinates,data,measuresLength,columnsN,dataMatrix,y,i,j);      }    }  } else {    for (int i=0; i < data.size(); i=i + measuresLength) {      for (int j=0; j < measuresLength; j++) {        y=getDataMatrix_extraction_3(columnsSpecification,rowsSpecification,columnCordinates,rowCordinates,data,measuresLength,columnsN,dataMatrix,y,i,j);      }    }  }  return dataMatrix;}",
            "extraction_name": "Extraction3",
            "prediction": "getDataMatrixSetup",
            "similarity": null,
            "file_name": "knowage-core.src.main.java.it.eng.spagobi.tools.dataset.crosstab.CrossTab.getDataMatrix.Extraction3.java",
            "updated_code": "/**  * Get the matrix that represent the data * @param columnsSpecification: A list with all the possible coordinates of the columns * @param rowsSpecification:    A list with all the possible coordinates of the rows * @param columnCordinates:     A list with the column coordinates of all the data * @param rowCordinates:        A list with the column rows of all the data * @param data:                 A list with the data * @param measuresOnColumns:    true if the measures live in the columns, false if the measures live in the rows * @param measuresLength:       the number of the measures * @return the matrix that represent the data */private String[][] getDataMatrix(List<String> columnsSpecification,List<String> rowsSpecification,List<String> columnCordinates,List<String> rowCordinates,List<String> data,boolean measuresOnColumns,int measuresLength,int columnsN){  String[][] dataMatrix;  int x, y;  dataMatrix=getDataMatrixSetup(rowsSpecification,measuresOnColumns,measuresLength,columnsN);  if (measuresOnColumns) {    for (int i=0; i < data.size(); i=i + measuresLength) {      for (int j=0; j < measuresLength; j++) {        y=getDataMatrixCoordinates(columnsSpecification,rowsSpecification,columnCordinates,rowCordinates,data,measuresLength,columnsN,dataMatrix,y,i,j);      }    }  } else {    for (int i=0; i < data.size(); i=i + measuresLength) {      for (int j=0; j < measuresLength; j++) {        y=getDataMatrixCoordinates(columnsSpecification,rowsSpecification,columnCordinates,rowCordinates,data,measuresLength,columnsN,dataMatrix,y,i,j);      }    }  }  return dataMatrix;}"
        }
    ],
    "file_name": null
}